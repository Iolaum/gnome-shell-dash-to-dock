From 4a40b1de64ba83656f0df40cc8c91eb34cd4d302 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marco=20Trevisan=20=28Trevi=C3=B1o=29?= <mail@3v1n0.net>
Date: Wed, 18 Mar 2020 01:43:02 +0100
Subject: [PATCH 35/37] docking: Make sure we don't send the overview offscreen
 in extended mode

When we vertically extend the dash, due to the fact that the dash is part of
the overviewControls, we make its layoutManager to wrongly compute the
viewSelector size, that ends up offscreen.

So, workaround this by connecting to the overviewControl 'allocation-changed'
signal and compute the offset we need to apply not to go offscreen and we
set is as bottom margin.

Unfortunately, it looks like that even replacing the layout-manager with
another implementation to the overviewControls that does the same isn't
enough to make this not to happen, and so far I've not been able to track
down how to avoid this in any other way.

Fixes #1007
Fixes LP: #1834967
---
 docking.js | 40 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/docking.js b/docking.js
index 022954c..24d094f 100644
--- a/docking.js
+++ b/docking.js
@@ -461,6 +461,11 @@ var DockedDash = GObject.registerClass({
 
         this._injectionsHandler.destroy();
 
+        if (this._marginLater) {
+            Meta.later_remove(this._marginLater);
+            delete this._marginLater;
+        }
+
         // Remove barrier timeout
         if (this._removeBarrierTimeoutId > 0)
             GLib.source_remove(this._removeBarrierTimeoutId);
@@ -1100,7 +1105,40 @@ var DockedDash = GObject.registerClass({
             this.x = pos_x;
             this.y = workArea.y + Math.round((1 - fraction) / 2 * workArea.height);
 
+            let overviewControls = null;
+            if (!Main.overview.isDummy && this._isPrimaryMonitor()) {
+                overviewControls = Main.overview._overview._controls;
+
+                if (this._oldSelectorMargin)
+                    overviewControls.margin_bottom = this._oldSelectorMargin;
+                else
+                    this._oldSelectorMargin = overviewControls.margin_bottom;
+            }
+
+            this._signalsHandler.removeWithLabel('verticalOffsetChecker');
+
             if (extendHeight) {
+                if (overviewControls) {
+                    // This is a workaround for bug #1007
+                    this._signalsHandler.addWithLabel('verticalOffsetChecker', [
+                        overviewControls.layout_manager,
+                        'allocation-changed',
+                        () => {
+                            let [, y] = overviewControls.get_transformed_position();
+                            let [, height] = overviewControls.get_transformed_size();
+                            let monitor = Main.layoutManager.primaryMonitor;
+                            let contentY2 = monitor.y + y + height;
+                            let offset = Math.max(0, contentY2 - monitor.height);
+
+                            if (this._marginLater)
+                                Meta.later_remove(this._marginLater);
+                            this._marginLater = Meta.later_add(
+                                Meta.LaterType.BEFORE_REDRAW, () => {
+                                    Main.overview.viewSelector.margin_bottom = offset;
+                                });
+                        }]);
+                }
+
                 this.dash._container.set_height(this.height);
                 this.add_style_class_name('extended');
             }
@@ -1955,6 +1993,8 @@ var DockManager = class DashToDock_DockManager {
         this._restoreDash();
         this._deleteDocks();
         this._revertPanelCorners();
+        if (this._oldSelectorMargin)
+            Main.overview.viewSelector.margin_bottom = this._oldSelectorMargin;
         if (this._fm1Client) {
             this._fm1Client.destroy();
             this._fm1Client = null;
-- 
2.26.0

